diff --git a/simgear/io/sg_binobj.hxx b/simgear/io/sg_binobj.hxx
index 9a2f4485..64c279a5 100644
--- a/simgear/io/sg_binobj.hxx
+++ b/simgear/io/sg_binobj.hxx
@@ -150,6 +150,7 @@ private:
     std::vector<SGVec4f> colors;        // color list
     std::vector<SGVec3f> normals;       // normal list
     std::vector<SGVec2f> texcoords;     // texture coordinate list
+    std::vector<SGVec2f> overlaycoords; // overlay texture coordinate list
     std::vector<float>   va_flt;        // vertex attribute list (floats)
     std::vector<int>     va_int;        // vertex attribute list (ints) 
     
@@ -226,6 +227,9 @@ public:
     
     inline const std::vector<SGVec2f>& get_texcoords() const { return texcoords; }
     inline void set_texcoords( const std::vector<SGVec2f>& t ) { texcoords = t; }
+
+    inline const std::vector<SGVec2f>& get_overlaycoords() const { return overlaycoords; }
+    inline void set_overlaycoords( const std::vector<SGVec2f>& t ) { overlaycoords = t; }
     
     // Points API
     bool add_point( const SGBinObjectPoint& pt );
diff --git a/simgear/scene/tgdb/SGTexturedTriangleBin.hxx b/simgear/scene/tgdb/SGTexturedTriangleBin.hxx
index b39ead0a..90d84f1c 100644
--- a/simgear/scene/tgdb/SGTexturedTriangleBin.hxx
+++ b/simgear/scene/tgdb/SGTexturedTriangleBin.hxx
@@ -89,10 +89,14 @@ struct SGVertNormTex {
   }
   const SGVec2f& GetTexCoord( unsigned idx ) const { return texCoord[idx]; }
 
+  void SetOverlayCoord( const SGVec2f& ovc )  { overlayCoord = ovc; }
+  const SGVec2f& GetOverlayCoord() const { return overlayCoord; }
+
 private:  
   SGVec3f vertex;
   SGVec3f normal;
   SGVec2f texCoord[4];
+  SGVec2f overlayCoord;
   
   unsigned tc_mask;
 };
@@ -432,6 +436,7 @@ public:
     osg::ref_ptr<osg::Vec3Array> normals = new osg::Vec3Array;
     osg::ref_ptr<osg::Vec2Array> priTexCoords = new osg::Vec2Array;
     osg::ref_ptr<osg::Vec2Array> secTexCoords = new osg::Vec2Array;
+    osg::ref_ptr<osg::Vec2Array> overlayCoords = new osg::Vec2Array;
 
     osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;
     colors->push_back(osg::Vec4(1, 1, 1, 1));
@@ -453,7 +458,8 @@ public:
         geometry->setTexCoordArray(1, secTexCoords);
     } else {
         geometry->setTexCoordArray(0, priTexCoords);
-    }        
+    }
+    geometry->setVertexAttribArray(14, overlayCoords.get(), osg::Array::BIND_PER_VERTEX);
 
     const unsigned invalid = ~unsigned(0);
     std::vector<unsigned> indexMap(getNumVertices(), invalid);
@@ -469,6 +475,7 @@ public:
         if ( has_sec_tcs ) {
             secTexCoords->push_back(toOsg(getVertex(triangle[0]).GetTexCoord(1)));
         }
+        overlayCoords->push_back(toOsg(getVertex(triangle[0]).GetOverlayCoord()));
       }
       deFacade.push_back(indexMap[triangle[0]]);
 
@@ -480,6 +487,7 @@ public:
         if ( has_sec_tcs ) {
             secTexCoords->push_back(toOsg(getVertex(triangle[1]).GetTexCoord(1)));
         }
+        overlayCoords->push_back(toOsg(getVertex(triangle[1]).GetOverlayCoord()));
       }
       deFacade.push_back(indexMap[triangle[1]]);
 
@@ -491,6 +499,7 @@ public:
         if ( has_sec_tcs ) {
             secTexCoords->push_back(toOsg(getVertex(triangle[2]).GetTexCoord(1)));
         }
+        overlayCoords->push_back(toOsg(getVertex(triangle[2]).GetOverlayCoord()));
       }
       deFacade.push_back(indexMap[triangle[2]]);
     }
diff --git a/simgear/scene/tgdb/SGTileGeometryBin.hxx b/simgear/scene/tgdb/SGTileGeometryBin.hxx
index 409ded6c..540982d6 100644
--- a/simgear/scene/tgdb/SGTileGeometryBin.hxx
+++ b/simgear/scene/tgdb/SGTileGeometryBin.hxx
@@ -58,6 +58,7 @@ public:
     const std::vector<SGVec3d>& vertices(obj.get_wgs84_nodes());
     const std::vector<SGVec3f>& normals(obj.get_normals());
     const std::vector<SGVec2f>& texCoords(obj.get_texcoords());
+    const std::vector<SGVec2f>& overlayCoords(obj.get_overlaycoords());
     const int_list& tris_v(obj.get_tris_v()[grp]);
     const int_list& tris_n(obj.get_tris_n()[grp]);
     const tci_list& tris_tc(obj.get_tris_tcs()[grp]);
@@ -82,6 +83,8 @@ public:
         if (!tris_tc[1].empty()) {
             v0.SetTexCoord( 1, getTexCoord(texCoords, tris_tc[1], tc1Scale, i-2) );
         }
+        v0.SetOverlayCoord(overlayCoords[tris_v[i-2]]);
+
         SGVertNormTex v1;
         v1.SetVertex( toVec3f(vertices[tris_v[i-1]]) );
         v1.SetNormal( num_norms_is_num_verts ? normals[tris_n[i-1]] : 
@@ -90,6 +93,8 @@ public:
         if (!tris_tc[1].empty()) {
             v1.SetTexCoord( 1, getTexCoord(texCoords, tris_tc[1], tc1Scale, i-1) );
         }
+        v1.SetOverlayCoord(overlayCoords[tris_v[i-1]]);
+
         SGVertNormTex v2;
         v2.SetVertex( toVec3f(vertices[tris_v[i]]) );
         v2.SetNormal( num_norms_is_num_verts ? normals[tris_n[i]] : 
@@ -98,6 +103,7 @@ public:
         if (!tris_tc[1].empty()) {
             v2.SetTexCoord( 1, getTexCoord(texCoords, tris_tc[1], tc1Scale, i) );
         }
+        v2.SetOverlayCoord(overlayCoords[tris_v[i]]);
         
         triangles.insert(v0, v1, v2);
     }
@@ -168,6 +174,7 @@ public:
       const std::vector<SGVec3d>& vertices(obj.get_wgs84_nodes());
       const std::vector<SGVec3f>& normals(obj.get_normals());
       const std::vector<SGVec2f>& texCoords(obj.get_texcoords());
+      const std::vector<SGVec2f>& overlayCoords(obj.get_overlaycoords());
       const int_list& fans_v(obj.get_fans_v()[grp]);
       const int_list& fans_n(obj.get_fans_n()[grp]);
       const tci_list& fans_tc(obj.get_fans_tcs()[grp]);
@@ -191,6 +198,8 @@ public:
     if (!fans_tc[1].empty()) {
         v0.SetTexCoord( 1, getTexCoord(texCoords, fans_tc[1], tc1Scale, 0) );
     }
+    v0.SetOverlayCoord(overlayCoords[fans_v[0]]);
+
     SGVertNormTex v1;
     v1.SetVertex( toVec3f(vertices[fans_v[1]]) );
     v1.SetNormal( num_norms_is_num_verts ? normals[fans_n[1]] : 
@@ -199,6 +208,8 @@ public:
     if (!fans_tc[1].empty()) {
         v1.SetTexCoord( 1, getTexCoord(texCoords, fans_tc[1], tc1Scale, 1) );
     }
+    v1.SetOverlayCoord(overlayCoords[fans_v[1]]);
+
     for (unsigned i = 2; i < fans_v.size(); ++i) {
       SGVertNormTex v2;
       v2.SetVertex( toVec3f(vertices[fans_v[i]]) );
@@ -208,6 +219,8 @@ public:
       if (!fans_tc[1].empty()) {
           v2.SetTexCoord( 1, getTexCoord(texCoords, fans_tc[1], tc1Scale, i) );
       }
+      v2.SetOverlayCoord(overlayCoords[fans_v[i]]);
+      
       triangles.insert(v0, v1, v2);
       v1 = v2;
     }
diff --git a/simgear/scene/tgdb/obj.cxx b/simgear/scene/tgdb/obj.cxx
index 5d3461f5..ba692576 100644
--- a/simgear/scene/tgdb/obj.cxx
+++ b/simgear/scene/tgdb/obj.cxx
@@ -26,10 +26,18 @@
 #  include <simgear_config.h>
 #endif
 
+#include <osgDB/FileNameUtils>
+#include <osgDB/FileUtils>
+#include <osgDB/ReadFile>
+#include <osg/Texture2D>
+#include <osg/TexEnv>
+
 #include "obj.hxx"
 
 #include <simgear/debug/logstream.hxx>
 #include <simgear/io/sg_binobj.hxx>
+#include <simgear/bucket/newbucket.hxx>
+#include <simgear/scene/util/OrthophotoManager.hxx>
 
 #include "SGTileGeometryBin.hxx"        // for original tile loading
 #include "SGTileDetailsCallback.hxx"    // for tile details ( random objects, and lighting )
@@ -54,6 +62,7 @@ SGLoadBTG(const std::string& path, const simgear::SGReaderWriterOptions* options
     double maxError    = SG_SIMPLIFIER_MAX_ERROR;
     double object_range = SG_OBJECT_RANGE_ROUGH;
     double tile_min_expiry = SG_TILE_MIN_EXPIRY;
+    bool usePhotoscenery = false;
 
     if (options) {
       matlib = options->getMaterialLib();
@@ -69,6 +78,7 @@ SGLoadBTG(const std::string& path, const simgear::SGReaderWriterOptions* options
       maxError = propertyNode->getDoubleValue("/sim/rendering/terrain/simplifier/max-error", maxError);
       object_range = propertyNode->getDoubleValue("/sim/rendering/static-lod/rough", object_range);
       tile_min_expiry= propertyNode->getDoubleValue("/sim/rendering/plod-minimum-expiry-time-secs", tile_min_expiry);
+      usePhotoscenery = propertyNode->getBoolValue("/sim/rendering/photoscenery/enabled", usePhotoscenery);
     }
 
     SGVec3d center = tile.get_gbs_center();
@@ -77,12 +87,60 @@ SGLoadBTG(const std::string& path, const simgear::SGReaderWriterOptions* options
     if (matlib)
     	matcache = matlib->generateMatCache(geodPos);
 
+    std::vector<SGVec3d> nodes = tile.get_wgs84_nodes();
+
+    std::vector<SGVec2f> satellite_overlay_coords;
+    osg::ref_ptr<Orthophoto> orthophoto = nullptr;
+
+    long index = strtol(osgDB::getSimpleFileName(osgDB::getNameLessExtension(path)).c_str(), NULL, 10);
+    if (index > 0) {
+      orthophoto = OrthophotoManager::instance()->getOrthophoto(index);
+    } else {
+      // Find the orthophoto by bounding box
+
+      SGRect<double> desired_bbox;
+      desired_bbox.setLeft(180.0);
+      desired_bbox.setRight(-180.0);
+      desired_bbox.setBottom(90.0);
+      desired_bbox.setTop(-90.0);
+      
+      // Find min/max lon/lat by brute force
+      for (unsigned i = 0; i < nodes.size(); ++i) {
+        SGGeod node_geod = SGGeod::fromCart(nodes[i] + center);
+        double lon_deg = node_geod.getLongitudeDeg();
+        double lat_deg = node_geod.getLatitudeDeg();
+
+        if (lon_deg < desired_bbox.l())
+          desired_bbox.setLeft(lon_deg);
+        if (lon_deg > desired_bbox.r())
+          desired_bbox.setRight(lon_deg);
+        if (lat_deg < desired_bbox.b())
+          desired_bbox.setBottom(lat_deg);
+        if (lat_deg > desired_bbox.t())
+          desired_bbox.setTop(lat_deg);
+      }
+
+      orthophoto = OrthophotoManager::instance()->getOrthophoto(desired_bbox);
+    }
+
     // rotate the tiles so that the bounding boxes get nearly axis aligned.
     // this will help the collision tree's bounding boxes a bit ...
-    std::vector<SGVec3d> nodes = tile.get_wgs84_nodes();
-    for (unsigned i = 0; i < nodes.size(); ++i)
+    for (unsigned i = 0; i < nodes.size(); ++i) {
+      if (orthophoto) {
+        // Generate TexCoords for Overlay
+        SGGeod node_geod = SGGeod::fromCart(nodes[i] + center);
+        SGRect<double> actual_bbox = orthophoto->getBbox();
+        float x = (node_geod.getLongitudeDeg() - actual_bbox.l()) / (actual_bbox.r() - actual_bbox.l());
+        float y = (actual_bbox.t() - node_geod.getLatitudeDeg()) / (actual_bbox.t() - actual_bbox.b());
+        satellite_overlay_coords.push_back(SGVec2f(x, y));
+      } else {
+        satellite_overlay_coords.push_back(SGVec2f(0.0, 0.0));
+      }
+
       nodes[i] = hlOr.transform(nodes[i]);
+    }
     tile.set_wgs84_nodes(nodes);
+    tile.set_overlaycoords(satellite_overlay_coords);
 
     SGQuatf hlOrf(hlOr[0], hlOr[1], hlOr[2], hlOr[3]);
     std::vector<SGVec3f> normals = tile.get_normals();
@@ -97,6 +155,23 @@ SGLoadBTG(const std::string& path, const simgear::SGReaderWriterOptions* options
       return NULL;
 
     osg::Node* node = tileGeometryBin->getSurfaceGeometry(matcache, useVBOs);
+
+    if (node) {
+      // Get base node stateset
+      osg::StateSet *stateSet = node->getOrCreateStateSet();
+
+      osg::ref_ptr<osg::Uniform> orthophotoAvailable = new osg::Uniform("orthophotoAvailable", false);
+      stateSet->addUniform(orthophotoAvailable, osg::StateAttribute::ON);
+
+      // Add satellite texture (if orthophoto exists)
+      if (usePhotoscenery && orthophoto) {
+        stateSet->setTextureAttributeAndModes(15, orthophoto->getTexture(), osg::StateAttribute::ON);
+        orthophotoAvailable->set(true);
+
+        SG_LOG(SG_TERRAIN, SG_INFO, "  Added satellite orthophoto for terrain object with path " << path);
+      }
+    }
+
     if (node && simplifyDistant) {
       osgUtil::Simplifier simplifier(ratio, maxError, maxLength);
       node->accept(simplifier);
diff --git a/simgear/scene/util/CMakeLists.txt b/simgear/scene/util/CMakeLists.txt
index 7177f87e..47a02dc3 100644
--- a/simgear/scene/util/CMakeLists.txt
+++ b/simgear/scene/util/CMakeLists.txt
@@ -7,6 +7,7 @@ set(HEADERS
     NodeAndDrawableVisitor.hxx
     Noise.hxx
     OptionsReadFileCallback.hxx
+    OrthophotoManager.hxx
     OsgDebug.hxx
     OsgMath.hxx
     OsgSingleton.hxx
@@ -40,6 +41,7 @@ set(SOURCES
     NodeAndDrawableVisitor.cxx
     Noise.cxx
     OptionsReadFileCallback.cxx
+    OrthophotoManager.cxx
     OsgDebug.cxx
     parse_color.cxx
     PrimitiveUtils.cxx
diff --git a/simgear/scene/util/OrthophotoManager.cxx b/simgear/scene/util/OrthophotoManager.cxx
new file mode 100644
index 00000000..fb1e1117
--- /dev/null
+++ b/simgear/scene/util/OrthophotoManager.cxx
@@ -0,0 +1,146 @@
+// OrthophotoManager.cxx -- manages satellite orthophotos
+//
+// Copyright (C) 2020  Nathaniel MacArthur-Warner nathanielwarner77@gmail.com
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the
+// Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+// Boston, MA  02110-1301, USA.
+
+#include "OrthophotoManager.hxx"
+
+namespace simgear {
+    Orthophoto::Orthophoto(osg::ref_ptr<osg::Image>& image, SGRect<double> bbox) {
+        _texture = new osg::Texture2D(image);
+        _texture->setWrap(osg::Texture::WrapParameter::WRAP_S, osg::Texture::WrapMode::CLAMP_TO_EDGE);
+        _texture->setWrap(osg::Texture::WrapParameter::WRAP_T, osg::Texture::WrapMode::CLAMP_TO_EDGE);
+        _texture->setWrap(osg::Texture::WrapParameter::WRAP_R, osg::Texture::WrapMode::CLAMP_TO_EDGE);
+        _texture->setMaxAnisotropy(SGSceneFeatures::instance()->getTextureFilter());
+        _bbox = bbox;
+    }
+
+    osg::ref_ptr<osg::Texture2D> Orthophoto::getTexture() {
+        return _texture;
+    }
+
+    SGRect<double> Orthophoto::getBbox() {
+        return _bbox;
+    }
+
+    OrthophotoManager* OrthophotoManager::instance() {
+        return SingletonRefPtr<OrthophotoManager>::instance();
+    }
+
+    void OrthophotoManager::addSceneryPath(const SGPath path) {
+        for (SGPath existingPath : _sceneryPaths) {
+            if (path == existingPath) {
+                return;
+            }
+        }
+        _sceneryPaths.push_front(path);
+    }
+
+    void OrthophotoManager::clearSceneryPaths() {
+        _sceneryPaths.clear();
+    }
+
+    void augmentBoundingBox(SGRect<double>& bbox, SGBucket& newBucket) {
+        double center_lon = newBucket.get_center_lon();
+        double center_lat = newBucket.get_center_lat();
+        double width = newBucket.get_width();
+        double height = newBucket.get_height();
+        double left = center_lon - width / 2;
+        double right = center_lon + width / 2;
+        double bottom = center_lat - height / 2;
+        double top = center_lat + height / 2;
+
+        if (bbox.l() > left)
+            bbox.setLeft(left);
+        if (bbox.r() < right)
+            bbox.setRight(right);
+        if (bbox.b() > bottom)
+            bbox.setBottom(bottom);
+        if (bbox.t() < top)
+            bbox.setTop(top);
+    }
+
+    osg::ref_ptr<osg::Image> OrthophotoManager::getBucketImage(SGBucket bucket) {
+        long index = bucket.gen_index();
+
+        osg::ref_ptr<osg::Image>& image = _bucketImages[index];
+
+        if (!image) {
+            std::string bucketPath = bucket.gen_base_path();
+
+            for (SGPath sceneryPath : _sceneryPaths) {
+                SGPath path = sceneryPath / "Orthophotos" / bucketPath / std::to_string(index);
+                path.concat(".png");
+                if (path.exists()) {
+                    image = osgDB::readRefImageFile(path.str());
+                    break;
+                }
+            }
+        }
+
+        return image;
+    }
+
+    SGRect<double> initBoundingBox() {
+        SGRect<double> bbox;
+        bbox.setLeft(180.0);
+        bbox.setBottom(90.0);
+        bbox.setRight(-180.0);
+        bbox.setTop(-90.0);
+        return bbox;
+    }
+
+    osg::ref_ptr<Orthophoto> OrthophotoManager::getOrthophoto(long bucket_index) {
+        SGBucket bucket(bucket_index);
+        osg::ref_ptr<osg::Image> image = getBucketImage(bucket);
+
+        if (!image)
+            return nullptr;
+
+        SGRect<double> bbox = initBoundingBox();
+        augmentBoundingBox(bbox, bucket);
+        
+        return new Orthophoto(image, bbox);
+    }
+
+    osg::ref_ptr<Orthophoto> OrthophotoManager::getOrthophoto(SGRect<double> desired_bbox) {
+        
+        double eps = SG_EPSILON * SGD_RADIANS_TO_DEGREES;
+        desired_bbox.setLeft(desired_bbox.l() + eps);
+        desired_bbox.setBottom(desired_bbox.b() + eps);
+        desired_bbox.setRight(desired_bbox.r() - eps);
+        desired_bbox.setTop(desired_bbox.t() - eps);
+
+        SGBucket bottom_left_bucket(SGGeod::fromDeg(desired_bbox.l(), desired_bbox.b()));
+        osg::ref_ptr<osg::Image> bottom_left_image = getBucketImage(bottom_left_bucket);
+
+        if (!bottom_left_image)
+            return nullptr;
+        
+        SGRect<double> actual_bbox = initBoundingBox();
+        augmentBoundingBox(actual_bbox, bottom_left_bucket);
+
+        // Simplest case - we already have the full orthophoto
+        if (actual_bbox.r() > desired_bbox.r() && actual_bbox.t() > desired_bbox.t())
+            return new Orthophoto(bottom_left_image, actual_bbox);
+        
+
+        // More complex case - we need to create a composite orthophoto
+        // For now, we leave it blank. (don't apply orthophoto)
+        return nullptr;
+    }
+}
diff --git a/simgear/scene/util/OrthophotoManager.hxx b/simgear/scene/util/OrthophotoManager.hxx
new file mode 100644
index 00000000..68b77b20
--- /dev/null
+++ b/simgear/scene/util/OrthophotoManager.hxx
@@ -0,0 +1,61 @@
+// OrthophotoManager.hxx -- manages satellite orthophotos
+//
+// Copyright (C) 2020  Nathaniel MacArthur-Warner nathanielwarner77@gmail.com
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the
+// Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+// Boston, MA  02110-1301, USA.
+
+#ifndef SG_SCENE_ORTHOPHOTO_MANAGER
+#define SG_SCENE_ORTHOPHOTO_MANAGER
+
+#include <unordered_map>
+
+#include <osg/Referenced>
+#include <osg/Image>
+#include <osg/Texture2D>
+#include <osgDB/ReaderWriter>
+#include <osgDB/ReadFile>
+#include <simgear/misc/sg_path.hxx>
+#include <simgear/bucket/newbucket.hxx>
+#include <simgear/math/SGRect.hxx>
+#include "SGSceneFeatures.hxx"
+#include "OsgSingleton.hxx"
+
+namespace simgear {
+    class Orthophoto : public osg::Referenced {
+    private:
+        osg::ref_ptr<osg::Texture2D> _texture;
+        SGRect<double> _bbox;
+    public:
+        Orthophoto(osg::ref_ptr<osg::Image>& image, SGRect<double> bbox);
+        osg::ref_ptr<osg::Texture2D> getTexture();
+        SGRect<double> getBbox();
+    };
+
+    class OrthophotoManager : public osg::Referenced {
+    private:
+        std::deque<SGPath> _sceneryPaths;
+        std::unordered_map<long, osg::ref_ptr<osg::Image>> _bucketImages;
+        osg::ref_ptr<osg::Image> getBucketImage(SGBucket bucket);
+    public:
+        static OrthophotoManager* instance();
+        void addSceneryPath(const SGPath path);
+        void clearSceneryPaths();
+        osg::ref_ptr<Orthophoto> getOrthophoto(long bucket_index);
+        osg::ref_ptr<Orthophoto> getOrthophoto(SGRect<double> desired_bbox);
+    };
+}
+
+#endif
\ No newline at end of file
